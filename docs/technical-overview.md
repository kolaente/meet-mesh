# Meet Mesh - Technical Overview & Implementation Plan

**Goal:** Build a self-hosted scheduling app combining Calendly-style booking with Doodle-style group coordination.

**Architecture:** Monorepo with Go backend (ogen + GORM + SQLite) and SvelteKit frontend. CalDAV integration for real-time calendar availability. OIDC for organizer auth, token-based links for guests.

**Tech Stack:** Go, ogen (OpenAPI codegen), GORM, SQLite, SvelteKit (Svelte 5), Tailwind CSS v3, CalDAV client library

---

## Tech Stack

- **Backend:** Go + ogen (OpenAPI v3 codegen) + GORM + SQLite
- **Frontend:** SvelteKit (Svelte 5) + Tailwind CSS v3
- **Auth:** OIDC for organizer, JWT tokens for email action links
- **Calendar:** CalDAV client (github.com/emersion/go-webdav)
- **Email:** SMTP via gomail or similar

---

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    Frontend (SvelteKit)                     │
│  - Svelte 5 with Runes ($state, $derived, $effect)         │
│  - Tailwind CSS for styling                                 │
│  - SSR for public pages, SPA-like for dashboard            │
└─────────────────────────────────────────────────────────────┘
                              │
                              │ REST API (JSON)
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                      API (Go + ogen)                        │
│  - OpenAPI spec → generated handlers                        │
│  - GORM ORM                                                 │
│  - OIDC authentication (organizer)                          │
│  - Token-based auth (email actions)                         │
│  - CalDAV client for availability                           │
│  - SMTP for notifications                                   │
└─────────────────────────────────────────────────────────────┘
                              │
              ┌───────────────┼───────────────┐
              ▼               ▼               ▼
        ┌──────────┐   ┌──────────┐   ┌──────────┐
        │  SQLite  │   │  CalDAV  │   │   SMTP   │
        │ Database │   │ Server(s)│   │  Server  │
        └──────────┘   └──────────┘   └──────────┘
```

---

## Project Structure

```
meet-mesh/
├── api/
│   ├── cmd/
│   │   └── main.go              # Wire up server, start listening
│   ├── openapi.yaml             # OpenAPI v3 spec (source of truth)
│   ├── gen/                     # Generated by ogen (don't edit)
│   ├── handler.go               # Implements gen.Handler interface
│   ├── handler_*.go             # Split handlers by domain
│   ├── security.go              # Implements gen.SecurityHandler
│   ├── models.go                # GORM models
│   ├── caldav.go                # CalDAV client wrapper
│   ├── mailer.go                # Email sending
│   ├── config.go                # Configuration loading
│   ├── gen.go                   # //go:generate ogen
│   └── go.mod
│
├── frontend/
│   ├── src/
│   │   ├── lib/
│   │   │   ├── components/      # Svelte components
│   │   │   └── api.ts           # API client
│   │   └── routes/
│   │       ├── (dashboard)/     # Organizer authenticated views
│   │       ├── (public)/        # Guest public views
│   │       └── (actions)/       # Email action pages
│   ├── tailwind.config.js
│   └── package.json
│
├── docs/
│   └── spec.md
│
└── plans/
```

---

## Data Models (GORM)

```go
// User - organizer (single-user deployment)
type User struct {
    ID        uint      `gorm:"primaryKey"`
    OIDCSub   string    `gorm:"uniqueIndex;not null"` // OIDC subject identifier
    Email     string    `gorm:"not null"`
    Name      string
    CreatedAt time.Time
    Calendars []CalendarConnection `gorm:"foreignKey:UserID"`
    Links     []Link               `gorm:"foreignKey:UserID"`
}

// CalendarConnection - CalDAV calendar integration
type CalendarConnection struct {
    ID           uint      `gorm:"primaryKey"`
    UserID       uint      `gorm:"index;not null"`
    ServerURL    string    `gorm:"not null"`           // CalDAV server URL
    Username     string    `gorm:"not null"`
    Password     string    `gorm:"not null"`           // Encrypted
    CalendarURLs []string  `gorm:"serializer:json"`    // Calendars to read for availability
    WriteURL     string                                 // Calendar to write events to
    CreatedAt    time.Time
    UpdatedAt    time.Time
}

// Link types
const (
    LinkTypeBooking LinkType = iota + 1
    LinkTypePoll
)

type LinkType int

// Slot types
const (
    SlotTypeTime SlotType = iota + 1
    SlotTypeFullDay
    SlotTypeMultiDay
)

type SlotType int

// Link statuses
const (
    LinkStatusActive LinkStatus = iota + 1
    LinkStatusClosed
)

type LinkStatus int

// AvailabilityRule defines when the organizer is available for bookings
type AvailabilityRule struct {
    DaysOfWeek []int  `json:"days_of_week"` // 0=Sunday, 6=Saturday
    StartTime  string `json:"start_time"`   // "09:00" (local time)
    EndTime    string `json:"end_time"`     // "17:00" (local time)
}

// CustomFieldType enum
const (
    CustomFieldTypeText CustomFieldType = iota + 1
    CustomFieldTypeEmail
    CustomFieldTypePhone
    CustomFieldTypeSelect
    CustomFieldTypeTextarea
)

type CustomFieldType int

// CustomField defines a form field for guest input
type CustomField struct {
    Name     string          `json:"name"`              // field identifier
    Label    string          `json:"label"`             // display label
    Type     CustomFieldType `json:"type"`              // field type
    Required bool            `json:"required"`          // is required
    Options  []string        `json:"options,omitempty"` // for select type
}

// EventTemplate defines how calendar events are created
type EventTemplate struct {
    TitleTemplate       string `json:"title_template"`       // e.g., "Meeting with {{guest_name}}"
    DescriptionTemplate string `json:"description_template"` // supports {{field_name}} placeholders
    Location            string `json:"location,omitempty"`
}

// Link - booking link or poll
type Link struct {
    ID          uint       `gorm:"primaryKey"`
    UserID      uint       `gorm:"index;not null"`
    Slug        string     `gorm:"uniqueIndex;not null"` // URL slug
    Type        LinkType   `gorm:"not null"`             // LinkTypeBooking or LinkTypePoll
    Name        string     `gorm:"not null"`
    Description string
    Status      LinkStatus `gorm:"not null;default:1"`   // LinkStatusActive, LinkStatusClosed

    // Booking-specific
    AutoConfirm       bool
    AvailabilityRules []*AvailabilityRule `gorm:"serializer:json"` // when organizer is available

    // Poll-specific
    ShowResults  bool
    RequireEmail bool

    // Shared
    CustomFields  []*CustomField `gorm:"serializer:json"` // form fields for guests
    EventTemplate *EventTemplate `gorm:"serializer:json"` // calendar event template (nil = use defaults)

    CreatedAt time.Time
    UpdatedAt time.Time

    Slots    []*Slot    `gorm:"foreignKey:LinkID"`
    Bookings []*Booking `gorm:"foreignKey:LinkID"`
    Votes    []*Vote    `gorm:"foreignKey:LinkID"`
}

// Slot - time slot or option for a link
// Type is per-slot, allowing mixed types within a single link
// (e.g., a poll with both "2pm Tuesday" time slots and "Wednesday anytime" full-day options)
type Slot struct {
    ID        uint      `gorm:"primaryKey"`
    LinkID    uint      `gorm:"index;not null"`
    Type      SlotType  `gorm:"not null"`  // SlotTypeTime, SlotTypeFullDay, SlotTypeMultiDay
    StartTime time.Time `gorm:"not null"`
    EndTime   time.Time `gorm:"not null"`
    Manual    bool      // true if manually added, false if auto-generated
    CreatedAt time.Time
}

// Booking statuses
const (
    BookingStatusPending BookingStatus = iota + 1
    BookingStatusConfirmed
    BookingStatusDeclined
)

type BookingStatus int

// Booking - guest booking on a booking link
type Booking struct {
    ID           uint               `gorm:"primaryKey"`
    LinkID       uint               `gorm:"index;not null"`
    SlotID       uint               `gorm:"index;not null"`
    GuestEmail   string             `gorm:"not null"`
    GuestName    string
    CustomFields map[string]string  `gorm:"serializer:json"` // field name -> value
    Status       BookingStatus      `gorm:"not null;default:1"` // BookingStatusPending, BookingStatusConfirmed, BookingStatusDeclined
    ActionToken  string             `gorm:"uniqueIndex"` // For email approve/decline links
    CalendarUID  string             // UID of created calendar event
    CreatedAt    time.Time
    UpdatedAt    time.Time

    Link Link
    Slot Slot
}

// VoteResponse enum
const (
    VoteResponseYes VoteResponse = iota + 1
    VoteResponseNo
    VoteResponseMaybe
)

type VoteResponse int

// Vote - guest vote on a poll
type Vote struct {
    ID           uint                  `gorm:"primaryKey"`
    LinkID       uint                  `gorm:"index;not null"`
    GuestEmail   string                // Optional
    GuestName    string                // Optional or anonymous
    Responses    map[uint]VoteResponse `gorm:"serializer:json;not null"` // slotID -> response
    CustomFields map[string]string     `gorm:"serializer:json"`          // field name -> value
    CreatedAt    time.Time

    Link Link
}
```

---

## OpenAPI Spec Structure

```yaml
openapi: 3.0.3
info:
  title: Meet Mesh API
  version: 1.0.0

components:
  securitySchemes:
    oidcAuth:
      type: openIdConnect
      openIdConnectUrl: /.well-known/openid-configuration
    actionToken:
      type: apiKey
      in: query
      name: token

  schemas:
    # Enum types (int constants)
    LinkType:
      type: integer
      enum: [1, 2]
      x-enum-varnames: [booking, poll]
      description: "1=booking, 2=poll"

    SlotType:
      type: integer
      enum: [1, 2, 3]
      x-enum-varnames: [time, full_day, multi_day]
      description: "1=time, 2=full_day, 3=multi_day"

    LinkStatus:
      type: integer
      enum: [1, 2]
      x-enum-varnames: [active, closed]
      description: "1=active, 2=closed"

    BookingStatus:
      type: integer
      enum: [1, 2, 3]
      x-enum-varnames: [pending, confirmed, declined]
      description: "1=pending, 2=confirmed, 3=declined"

    CustomFieldType:
      type: integer
      enum: [1, 2, 3, 4, 5]
      x-enum-varnames: [text, email, phone, select, textarea]
      description: "1=text, 2=email, 3=phone, 4=select, 5=textarea"

    VoteResponse:
      type: integer
      enum: [1, 2, 3]
      x-enum-varnames: [yes, no, maybe]
      description: "1=yes, 2=no, 3=maybe"

    AvailabilityRule:
      type: object
      properties:
        days_of_week: { type: array, items: { type: integer, minimum: 0, maximum: 6 } }
        start_time: { type: string, pattern: "^[0-2][0-9]:[0-5][0-9]$" }
        end_time: { type: string, pattern: "^[0-2][0-9]:[0-5][0-9]$" }

    CustomField:
      type: object
      properties:
        name: { type: string }
        label: { type: string }
        type: { $ref: '#/components/schemas/CustomFieldType' }
        required: { type: boolean }
        options: { type: array, items: { type: string } }

    EventTemplate:
      type: object
      properties:
        title_template: { type: string }
        description_template: { type: string }
        location: { type: string }

    Link:
      type: object
      properties:
        id: { type: integer }
        slug: { type: string }
        type: { $ref: '#/components/schemas/LinkType' }
        name: { type: string }
        description: { type: string }
        status: { $ref: '#/components/schemas/LinkStatus' }
        auto_confirm: { type: boolean }
        show_results: { type: boolean }
        require_email: { type: boolean }
        availability_rules: { type: array, items: { $ref: '#/components/schemas/AvailabilityRule' } }
        custom_fields: { type: array, items: { $ref: '#/components/schemas/CustomField' } }
        event_template: { $ref: '#/components/schemas/EventTemplate' }
        created_at: { type: string, format: date-time }

    Slot:
      type: object
      properties:
        id: { type: integer }
        type: { $ref: '#/components/schemas/SlotType' }
        start_time: { type: string, format: date-time }
        end_time: { type: string, format: date-time }

    AvailableSlot:
      type: object
      properties:
        start_time: { type: string, format: date-time }
        end_time: { type: string, format: date-time }

    Booking:
      type: object
      properties:
        id: { type: integer }
        slot: { $ref: '#/components/schemas/Slot' }
        guest_email: { type: string }
        guest_name: { type: string }
        status: { $ref: '#/components/schemas/BookingStatus' }
        custom_fields:
          type: object
          additionalProperties: { type: string }
        created_at: { type: string, format: date-time }

    Vote:
      type: object
      properties:
        id: { type: integer }
        guest_name: { type: string }
        responses:
          type: object
          additionalProperties: { $ref: '#/components/schemas/VoteResponse' }
        custom_fields:
          type: object
          additionalProperties: { type: string }
        created_at: { type: string, format: date-time }

    VoteTally:
      type: object
      properties:
        slot_id: { type: integer }
        yes_count: { type: integer }
        no_count: { type: integer }
        maybe_count: { type: integer }

    CustomField:
      type: object
      properties:
        name: { type: string }
        label: { type: string }
        type: { type: string, enum: [text, email, phone, select, textarea] }
        required: { type: boolean }
        options: { type: array, items: { type: string } }

paths:
  # Auth
  /auth/login:
    get:
      operationId: initiateLogin
      # Redirect to OIDC provider
  /auth/callback:
    get:
      operationId: authCallback
      # Handle OIDC callback
  /auth/logout:
    post:
      operationId: logout
      security: [{ oidcAuth: [] }]
  /auth/me:
    get:
      operationId: getCurrentUser
      security: [{ oidcAuth: [] }]

  # Calendar connections (organizer)
  /calendars:
    get:
      operationId: listCalendars
      security: [{ oidcAuth: [] }]
    post:
      operationId: addCalendar
      security: [{ oidcAuth: [] }]
  /calendars/{id}:
    delete:
      operationId: removeCalendar
      security: [{ oidcAuth: [] }]

  # Links (organizer)
  /links:
    get:
      operationId: listLinks
      security: [{ oidcAuth: [] }]
    post:
      operationId: createLink
      security: [{ oidcAuth: [] }]
  /links/{id}:
    get:
      operationId: getLink
      security: [{ oidcAuth: [] }]
    put:
      operationId: updateLink
      security: [{ oidcAuth: [] }]
    delete:
      operationId: deleteLink
      security: [{ oidcAuth: [] }]

  # Link management (organizer)
  /links/{id}/slots:
    get:
      operationId: getLinkSlots
      security: [{ oidcAuth: [] }]
    post:
      operationId: addSlot
      security: [{ oidcAuth: [] }]
  /links/{id}/bookings:
    get:
      operationId: getLinkBookings
      security: [{ oidcAuth: [] }]
  /links/{id}/votes:
    get:
      operationId: getLinkVotes
      security: [{ oidcAuth: [] }]
  /links/{id}/pick-winner:
    post:
      operationId: pickPollWinner
      security: [{ oidcAuth: [] }]

  # Booking management (organizer)
  /bookings/{id}/approve:
    post:
      operationId: approveBooking
      security: [{ oidcAuth: [] }]
  /bookings/{id}/decline:
    post:
      operationId: declineBooking
      security: [{ oidcAuth: [] }]

  # Public guest endpoints (no auth)
  /p/{slug}:
    get:
      operationId: getPublicLink
      # Returns link info for guests
  /p/{slug}/availability:
    get:
      operationId: getAvailability
      # Returns available slots (real-time CalDAV check)
  /p/{slug}/book:
    post:
      operationId: createBooking
      # Guest submits booking
  /p/{slug}/vote:
    post:
      operationId: submitVote
      # Guest submits poll vote
  /p/{slug}/results:
    get:
      operationId: getPollResults
      # Get vote tally (if enabled)

  # Email action endpoints (token auth)
  /actions/approve:
    get:
      operationId: approveViaEmail
      security: [{ actionToken: [] }]
  /actions/decline:
    get:
      operationId: declineViaEmail
      security: [{ actionToken: [] }]
```

---

## Handler Implementation Pattern

```go
// handler.go
type Handler struct {
    db      *gorm.DB
    caldav  *CalDAVClient
    mailer  *Mailer
    config  *Config
}

var _ gen.Handler = (*Handler)(nil)

// Example: Get available slots for a booking link
func (h *Handler) GetAvailability(ctx context.Context, params gen.GetAvailabilityParams) (*gen.AvailabilityResponse, error) {
    var link Link
    if err := h.db.Where("slug = ? AND status = ?", params.Slug, LinkStatusActive).First(&link).Error; err != nil {
        return nil, gen.ErrNotFound
    }

    if link.Type != LinkTypeBooking {
        return nil, gen.ErrBadRequest
    }

    // Fetch busy times from CalDAV
    busyTimes, err := h.caldav.GetBusyTimes(ctx, link.UserID, params.Start, params.End)
    if err != nil {
        return nil, err
    }

    // Generate available slots based on availability rules
    slots := h.generateSlots(link, params.Start, params.End, busyTimes)

    return &gen.AvailabilityResponse{
        Slots: mapSlotsToDTO(slots),
    }, nil
}
```

```go
// security.go
type SecurityHandler struct {
    config   *Config
    oidc     *oidc.Provider
    verifier *oidc.IDTokenVerifier
}

// OIDC auth for organizer endpoints
func (s *SecurityHandler) HandleOidcAuth(ctx context.Context, op string, t gen.OidcAuth) (context.Context, error) {
    // Validate session cookie containing ID token
    session, err := s.validateSession(ctx)
    if err != nil {
        return ctx, err
    }
    return WithUserID(ctx, session.UserID), nil
}

// Token auth for email action endpoints
func (s *SecurityHandler) HandleActionToken(ctx context.Context, op string, t gen.ActionToken) (context.Context, error) {
    booking, err := s.validateActionToken(t.APIKey)
    if err != nil {
        return ctx, err
    }
    return WithBookingID(ctx, booking.ID), nil
}
```

---

## CalDAV Integration

```go
// caldav.go
type CalDAVClient struct {
    db *gorm.DB
}

// GetBusyTimes fetches busy periods from all connected calendars
func (c *CalDAVClient) GetBusyTimes(ctx context.Context, userID uint, start, end time.Time) ([]TimePeriod, error) {
    var connections []CalendarConnection
    if err := c.db.Where("user_id = ?", userID).Find(&connections).Error; err != nil {
        return nil, err
    }

    var allBusy []TimePeriod
    for _, conn := range connections {
        client, err := webdav.NewClient(conn.ServerURL, conn.Username, conn.Password)
        if err != nil {
            continue // Log and skip
        }

        for _, calURL := range conn.CalendarURLs {
            events, err := client.QueryCalendar(ctx, calURL, start, end)
            if err != nil {
                continue
            }
            for _, event := range events {
                allBusy = append(allBusy, TimePeriod{
                    Start: event.Start,
                    End:   event.End,
                })
            }
        }
    }

    return mergePeriods(allBusy), nil
}

// CreateEvent creates a calendar event for a confirmed booking
func (c *CalDAVClient) CreateEvent(ctx context.Context, userID uint, booking *Booking, template EventTemplate) (string, error) {
    var conn CalendarConnection
    if err := c.db.Where("user_id = ? AND write_url != ''", userID).First(&conn).Error; err != nil {
        return "", err
    }

    client, err := webdav.NewClient(conn.ServerURL, conn.Username, conn.Password)
    if err != nil {
        return "", err
    }

    event := buildICalEvent(booking, template)
    uid, err := client.PutCalendarObject(ctx, conn.WriteURL, event)
    if err != nil {
        return "", err
    }

    return uid, nil
}
```

---

## Email Notifications

```go
// mailer.go
type Mailer struct {
    config *Config
}

func (m *Mailer) SendBookingConfirmation(booking *Booking, link *Link) error {
    // To guest
    m.send(booking.GuestEmail, "Booking Confirmed", m.renderTemplate("booking_confirmed_guest", map[string]any{
        "LinkName": link.Name,
        "Time":     booking.Slot.StartTime,
        "Details":  booking.CustomFields,
    }))

    // To organizer
    m.send(m.config.OrganizerEmail, "New Booking", m.renderTemplate("booking_confirmed_organizer", map[string]any{
        "LinkName":   link.Name,
        "GuestEmail": booking.GuestEmail,
        "Time":       booking.Slot.StartTime,
    }))

    return nil
}

func (m *Mailer) SendBookingPending(booking *Booking, link *Link) error {
    approveURL := fmt.Sprintf("%s/actions/approve?token=%s", m.config.BaseURL, booking.ActionToken)
    declineURL := fmt.Sprintf("%s/actions/decline?token=%s", m.config.BaseURL, booking.ActionToken)

    return m.send(m.config.OrganizerEmail, "Booking Request", m.renderTemplate("booking_pending", map[string]any{
        "LinkName":   link.Name,
        "GuestEmail": booking.GuestEmail,
        "Time":       booking.Slot.StartTime,
        "ApproveURL": approveURL,
        "DeclineURL": declineURL,
    }))
}

func (m *Mailer) SendPollWinner(link *Link, winningSlot *Slot, votes []Vote) error {
    for _, vote := range votes {
        if vote.GuestEmail == "" {
            continue
        }
        m.send(vote.GuestEmail, "Date Selected", m.renderTemplate("poll_winner", map[string]any{
            "LinkName": link.Name,
            "Time":     winningSlot.StartTime,
        }))
    }
    return nil
}
```

---

## Frontend Structure (SvelteKit)

```
frontend/src/
├── lib/
│   ├── components/
│   │   ├── SlotEditor.svelte        # Add/edit slots with per-slot type selection
│   │   ├── SlotPicker.svelte        # Guest: time slot selection UI
│   │   ├── DayPicker.svelte         # Guest: full day selection UI
│   │   ├── DateRangePicker.svelte   # Guest: multi-day selection UI
│   │   ├── CustomFieldForm.svelte   # Dynamic form for custom fields
│   │   ├── VoteGrid.svelte          # Poll voting grid (handles mixed slot types)
│   │   ├── VoteTally.svelte         # Poll results display
│   │   ├── BookingCard.svelte       # Booking summary card
│   │   ├── LinkCard.svelte          # Link summary for dashboard
│   │   └── CalendarSetup.svelte     # CalDAV connection form
│   └── api.ts
├── routes/
│   ├── +layout.svelte
│   ├── (dashboard)/                 # Organizer views (authenticated)
│   │   ├── +layout.svelte           # Auth guard, nav
│   │   ├── +page.svelte             # Dashboard overview
│   │   ├── links/
│   │   │   ├── +page.svelte         # List all links
│   │   │   ├── new/+page.svelte     # Create link wizard
│   │   │   └── [id]/
│   │   │       ├── +page.svelte     # Link detail (bookings/votes)
│   │   │       └── edit/+page.svelte
│   │   └── settings/
│   │       └── calendars/+page.svelte # CalDAV setup
│   ├── (public)/                    # Guest views (no auth)
│   │   └── p/[slug]/
│   │       ├── +page.svelte         # Booking or poll page
│   │       └── confirmed/+page.svelte
│   ├── (actions)/                   # Email action pages
│   │   └── actions/
│   │       ├── approve/+page.svelte
│   │       └── decline/+page.svelte
│   └── auth/
│       ├── login/+page.svelte
│       └── callback/+page.svelte
└── app.css
```

---

## Major Implementation Steps

### Phase 1: Foundation
1. **Project setup** - Initialize Go module, SvelteKit project, directory structure
2. **OpenAPI spec** - Define all endpoints, schemas, security schemes
3. **Generate backend** - Run ogen, set up GORM models, SQLite migrations
4. **Configuration** - Config file loading (OIDC, SMTP, database settings)

### Phase 2: Authentication
5. **OIDC integration** - Login flow, callback handler, session management
6. **Security handlers** - OIDC validation for organizer, token validation for actions

### Phase 3: CalDAV Integration
7. **CalDAV client** - Connect to CalDAV server, fetch calendars
8. **Availability queries** - Fetch busy times, merge multiple calendars
9. **Event creation** - Create calendar events for confirmed bookings

### Phase 4: Core API - Links
10. **Link CRUD** - Create, read, update, delete booking links and polls
11. **Slot management** - Manual slot creation, availability rules parsing
12. **Custom fields** - Field definition storage and validation

### Phase 5: Core API - Booking Flow
13. **Public link endpoint** - Return link info for guests
14. **Availability endpoint** - Real-time slot availability (CalDAV check)
15. **Booking submission** - Create booking, verify availability, trigger workflow
16. **Booking management** - Approve/decline, status updates

### Phase 6: Core API - Poll Flow
17. **Vote submission** - Store votes per guest
18. **Vote tally** - Aggregate and return results
19. **Pick winner** - Organizer selects winning slot, triggers notifications

### Phase 7: Email Notifications
20. **Mailer setup** - SMTP connection, template rendering
21. **Booking emails** - Confirmation, pending approval, approved/declined
22. **Poll emails** - Winner notification

### Phase 8: Frontend Foundation
23. **SvelteKit setup** - Project, Tailwind, layout structure
24. **API client** - Typed fetch wrapper for all endpoints
25. **Auth flow** - Login redirect, callback handling, session state

### Phase 9: Dashboard UI
26. **Dashboard page** - Overview of links and recent activity
27. **Link list** - All links with status filters
28. **Create link wizard** - Step-by-step form for booking/poll creation
29. **Link detail** - View bookings/votes, approve/decline, pick winner
30. **Calendar settings** - Add/remove CalDAV connections

### Phase 10: Public Guest UI
31. **Booking page** - Slot picker, custom fields form, submission
32. **Poll page** - Vote grid, optional email, submission
33. **Confirmation pages** - Success states

### Phase 11: Email Action Pages
34. **Approve/decline pages** - Token validation, action execution, feedback

### Phase 12: Polish
35. **Loading states** - Skeletons, spinners for async operations
36. **Error handling** - User-friendly error messages, validation feedback
37. **Empty states** - No links, no bookings, no votes

---

## Key Decisions

| Area | Decision |
|------|----------|
| API design | OpenAPI spec-first with ogen codegen |
| Monorepo | Single repo, `api/` and `frontend/` dirs |
| Auth (organizer) | OIDC with session cookies |
| Auth (guests) | No auth for booking/voting, optional email |
| Auth (email actions) | Single-use tokens in query params |
| Calendar | CalDAV via go-webdav library |
| Availability | Real-time CalDAV queries (cached briefly) |
| Database | SQLite for single-user self-hosted simplicity |
| Email | SMTP with HTML templates |
| Slot types | Per-slot type allows mixed types within a link |
| Custom fields | Typed structs with GORM JSON serializer |

---

## Configuration File

```yaml
# config.yaml
server:
  port: 8080
  base_url: https://meet.example.com

database:
  path: ./data/meet-mesh.db

oidc:
  issuer: https://auth.example.com
  client_id: meet-mesh
  client_secret: ${OIDC_CLIENT_SECRET}
  redirect_uri: https://meet.example.com/auth/callback

smtp:
  host: smtp.example.com
  port: 587
  username: meet-mesh@example.com
  password: ${SMTP_PASSWORD}
  from: "Meet Mesh <meet-mesh@example.com>"
```
